diff -r 40c18bb90501 -r 15d7327dfbd2 configs/common/SysPaths.py
--- a/configs/common/SysPaths.py	Fri Mar 23 10:34:02 2018 -0700
+++ b/configs/common/SysPaths.py	Sun Feb 10 21:13:14 2019 -0600
@@ -32,7 +32,7 @@
 config_root = os.path.dirname(config_path)
 
 class PathSearchFunc(object):
-    _sys_paths = None
+    _sys_paths = [ '/home/andrew/ece511/gem5/benchmarks/FSmode', '' ]
 
     def __init__(self, subdirs, sys_paths=None):
         if isinstance(subdirs, basestring):
diff -r 40c18bb90501 -r 15d7327dfbd2 src/cpu/pred/BranchPredictor.py
--- a/src/cpu/pred/BranchPredictor.py	Fri Mar 23 10:34:02 2018 -0700
+++ b/src/cpu/pred/BranchPredictor.py	Sun Feb 10 21:13:14 2019 -0600
@@ -86,6 +86,14 @@
     choicePredictorSize = Param.Unsigned(8192, "Size of choice predictor")
     choiceCtrBits = Param.Unsigned(2, "Bits of choice counters")
 
+class GShareBP(BranchPredictor):
+    type = 'GShareBP'
+    cxx_class = 'GShareBP'
+    cxx_header = "cpu/pred/gshare.hh"
+
+    phtPredictorSize = Param.Unsigned(8192, "Size of choice predictor")
+    phtCtrBits = Param.Unsigned(2, "Bits of choice counters")
+
 class LTAGE(BranchPredictor):
     type = 'LTAGE'
     cxx_class = 'LTAGE'
diff -r 40c18bb90501 -r 15d7327dfbd2 src/cpu/pred/SConscript
--- a/src/cpu/pred/SConscript	Fri Mar 23 10:34:02 2018 -0700
+++ b/src/cpu/pred/SConscript	Sun Feb 10 21:13:14 2019 -0600
@@ -43,6 +43,7 @@
 Source('ras.cc')
 Source('tournament.cc')
 Source ('bi_mode.cc')
+Source ('gshare.cc')
 Source('ltage.cc')
 DebugFlag('FreeList')
 DebugFlag('Branch')
diff -r 40c18bb90501 -r 15d7327dfbd2 src/cpu/pred/gshare.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/pred/gshare.cc	Sun Feb 10 21:13:14 2019 -0600
@@ -0,0 +1,151 @@
+
+/* @file
+ * Implementation of a GShare branch predictor
+ */
+
+#include "cpu/pred/gshare.hh"
+
+#include "base/bitfield.hh"
+#include "base/intmath.hh"
+
+GShareBP::GShareBP(const GShareBPParams *params)
+    : BPredUnit(params),
+      phtPredictorSize(params->phtPredictorSize),
+      phtCtrBits(params->phtCtrBits)
+{
+    if (!isPowerOf2(phtPredictorSize))
+        fatal("Invalid choice predictor size.\n");
+
+    phtCounters.resize(phtPredictorSize);
+
+    for (int i = 0; i < phtPredictorSize; ++i) {
+        phtCounters[i].setBits(phtCtrBits);
+    }
+
+    historyRegisterMask = mask(globalHistoryBits);
+    phtHistoryMask = phtPredictorSize - 1;
+
+    phtThreshold = (ULL(1) << (phtCtrBits - 1)) - 1;
+}
+
+/*
+ * For an unconditional branch mark it as taken.
+ */
+void
+GShareBP::uncondBranch(ThreadID tid, Addr pc, void * &bpHistory)
+{
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->pred = true;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, true);
+}
+
+void
+GShareBP::squash(ThreadID tid, void *bpHistory)
+{
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+    globalHistoryReg[tid] = history->globalHistoryReg;
+
+    delete history;
+}
+
+/*
+ * Look up the prediction for a branch. Use the PC and a hash of the 
+ * global history register to index into the PHT and return the
+ * prediction.
+ */
+bool
+GShareBP::lookup(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    unsigned phtHistoryIdx = ((branchAddr >> instShiftAmt)
+                                & phtHistoryMask);
+
+    assert(phtHistoryIdx < phtPredictorSize);
+
+    bool phtPrediction = phtCounters[phtHistoryIdx].read()
+                            > phtThreshold;
+
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->pred = phtPrediction;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, phtPrediction);
+
+    return phtPrediction;
+}
+
+void
+GShareBP::btbUpdate(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    globalHistoryReg[tid] &= (historyRegisterMask & ~ULL(1));
+}
+
+/* Only the selected direction predictor will be updated with the final
+ * outcome; the status of the unselected one will not be altered. The choice
+ * predictor is always updated with the branch outcome, except when the
+ * choice is opposite to the branch outcome but the selected counter of
+ * the direction predictors makes a correct final prediction.
+ */
+void
+GShareBP::update(ThreadID tid, Addr branchAddr, bool taken, void *bpHistory,
+                 bool squashed)
+{
+    assert(bpHistory);
+
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+
+    // We do not update the counters speculatively on a squash.
+    // We just restore the global history register.
+    if (squashed) {
+        globalHistoryReg[tid] = (history->globalHistoryReg << 1) | taken;
+        return;
+    }
+
+    unsigned phtHistoryIdx = ((branchAddr >> instShiftAmt)
+                                & phtHistoryMask);
+
+    assert(phtHistoryIdx < phtPredictorSize);
+
+    if (history->pred == taken) {
+      if(taken) {
+        /* Predicted taken correct */
+        phtCounters[phtHistoryIdx].increment();
+      }
+      else {
+        /* Predicted not taken correctly */
+        phtCounters[phtHistoryIdx].decrement();
+      } 
+    } else {
+      if (taken) {
+        /* Predicted taken incorrectly */
+        phtCounters[phtHistoryIdx].decrement();
+      }
+      else {
+        /* Predicted not taken incorrectly */
+        phtCounters[phtHistoryIdx].increment();
+      }
+    }
+
+    delete history;
+}
+
+unsigned
+GShareBP::getGHR(ThreadID tid, void *bp_history) const
+{
+    return static_cast<BPHistory*>(bp_history)->globalHistoryReg;
+}
+
+void
+GShareBP::updateGlobalHistReg(ThreadID tid, bool taken)
+{
+    globalHistoryReg[tid] = taken ? (globalHistoryReg[tid] << 1) | 1 :
+                               (globalHistoryReg[tid] << 1);
+    globalHistoryReg[tid] &= historyRegisterMask;
+}
+
+GShareBP*
+GShareBPParams::create()
+{
+    return new GShareBP(this);
+}
diff -r 40c18bb90501 -r 15d7327dfbd2 src/cpu/pred/gshare.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/pred/gshare.hh	Sun Feb 10 21:13:14 2019 -0600
@@ -0,0 +1,55 @@
+/* @file
+ * Implementation of a GShare branch predictor
+ */
+
+#ifndef __CPU_PRED_GSHARE_PRED_HH__
+#define __CPU_PRED_GSHARE_PRED_HH__
+
+#include "cpu/pred/bpred_unit.hh"
+#include "cpu/pred/sat_counter.hh"
+#include "params/GShareBP.hh"
+
+class GShareBP : public BPredUnit
+{
+  public:
+    GShareBP(const GShareBPParams *params);
+    void uncondBranch(ThreadID tid, Addr pc, void * &bp_history);
+    void squash(ThreadID tid, void *bp_history);
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed);
+    unsigned getGHR(ThreadID tid, void *bp_history) const;
+
+  private:
+    void updateGlobalHistReg(ThreadID tid, bool taken);
+
+    struct BPHistory {
+        unsigned globalHistoryReg;
+        // the final taken/not-taken prediction
+        // true: predict taken
+        // false: predict not-taken
+        bool pred;
+    };
+
+    // pattern history table predictors
+    std::vector<SatCounter> phtCounters;
+
+    std::vector<unsigned> globalHistoryReg;
+
+    unsigned historyRegister;
+
+    unsigned globalHistoryBits;
+    unsigned historyRegisterMask;
+
+    unsigned phtPredictorSize;
+    unsigned phtCtrBits;
+    unsigned phtHistoryMask;
+    unsigned globalPredictorSize;
+    unsigned globalCtrBits;
+    unsigned globalHistoryMask;
+
+    unsigned phtThreshold;
+};
+
+#endif // __CPU_PRED_BI_MODE_PRED_HH__
