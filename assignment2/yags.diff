diff -r 7f72aa0fe202 -r 6bb558b3407e src/cpu/pred/BranchPredictor.py
--- a/src/cpu/pred/BranchPredictor.py	Tue Feb 12 22:11:58 2019 -0600
+++ b/src/cpu/pred/BranchPredictor.py	Wed Feb 13 02:14:25 2019 -0600
@@ -86,6 +86,17 @@
     choicePredictorSize = Param.Unsigned(8192, "Size of choice predictor")
     choiceCtrBits = Param.Unsigned(2, "Bits of choice counters")
 
+class YagsBP(BranchPredictor):
+    type = 'YagsBP'
+    cxx_class = 'YagsBP'
+    cxx_header = "cpu/pred/yags.hh"
+
+    globalPredictorSize = Param.Unsigned(8192, "Size of global predictor")
+    globalCtrBits = Param.Unsigned(2, "Bits per counter")
+    choicePredictorSize = Param.Unsigned(8192, "Size of choice predictor")
+    choiceCtrBits = Param.Unsigned(2, "Bits of choice counters")
+    tagMask = Param.Unsigned(8, "Bit width of global predictor tags")
+
 class GShareBP(BranchPredictor):
     type = 'GShareBP'
     cxx_class = 'GShareBP'
diff -r 7f72aa0fe202 -r 6bb558b3407e src/cpu/pred/SConscript
--- a/src/cpu/pred/SConscript	Tue Feb 12 22:11:58 2019 -0600
+++ b/src/cpu/pred/SConscript	Wed Feb 13 02:14:25 2019 -0600
@@ -42,8 +42,9 @@
 Source('indirect.cc')
 Source('ras.cc')
 Source('tournament.cc')
-Source ('bi_mode.cc')
-Source ('gshare.cc')
+Source('bi_mode.cc')
+Source('gshare.cc')
+Source('yags.cc')
 Source('ltage.cc')
 DebugFlag('FreeList')
 DebugFlag('Branch')
diff -r 7f72aa0fe202 -r 6bb558b3407e src/cpu/pred/yags.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/pred/yags.cc	Wed Feb 13 02:14:25 2019 -0600
@@ -0,0 +1,231 @@
+/* @file
+ * Implementation of a yags branch predictor
+ */
+
+#include "cpu/pred/yags.hh"
+
+#include "base/bitfield.hh"
+#include "base/intmath.hh"
+
+YagsBP::YagsBP(const YagsBPParams *params)
+    : BPredUnit(params),
+      globalHistoryReg(params->numThreads, 0),
+      globalHistoryBits(ceilLog2(params->globalPredictorSize)),
+      choicePredictorSize(params->choicePredictorSize),
+      choiceCtrBits(params->choiceCtrBits),
+      globalPredictorSize(params->globalPredictorSize),
+      globalCtrBits(params->globalCtrBits),
+      tagMask(params->tagMask)
+{
+    if (!isPowerOf2(choicePredictorSize))
+        fatal("Invalid choice predictor size.\n");
+    if (!isPowerOf2(globalPredictorSize))
+        fatal("Invalid global history predictor size.\n");
+
+    choiceCounters.resize(choicePredictorSize);
+    takenCountersA.resize(globalPredictorSize);
+    takenTagsA.resize(globalPredictorSize);
+    takenCountersB.resize(globalPredictorSize);
+    takenTagsB.resize(globalPredictorSize);
+    takenLru.resize(globalPredictorSize);
+    notTakenCountersA.resize(globalPredictorSize);
+    notTakenTagsA.resize(globalPredictorSize);
+    notTakenCountersB.resize(globalPredictorSize);
+    notTakenTagsB.resize(globalPredictorSize);
+    notTakenLru.resize(globalPredictorSize);
+
+    for (int i = 0; i < choicePredictorSize; ++i) {
+        choiceCounters[i].setBits(choiceCtrBits);
+    }
+    for (int i = 0; i < globalPredictorSize; ++i) {
+        takenCountersA[i].setBits(globalCtrBits);
+        notTakenCountersA[i].setBits(globalCtrBits);
+        takenCountersB[i].setBits(globalCtrBits);
+        notTakenCountersB[i].setBits(globalCtrBits);
+    }
+
+    historyRegisterMask = mask(globalHistoryBits);
+    choiceHistoryMask = choicePredictorSize - 1;
+    globalHistoryMask = globalPredictorSize - 1;
+
+    choiceThreshold = (ULL(1) << (choiceCtrBits - 1)) - 1;
+    takenThreshold = (ULL(1) << (globalCtrBits - 1)) - 1;
+    notTakenThreshold = (ULL(1) << (globalCtrBits - 1)) - 1;
+}
+
+/*
+ * For an unconditional branch we set its history such that
+ * everything is set to taken. I.e., its choice predictor
+ * chooses the taken array and the taken array predicts taken.
+ */
+void
+YagsBP::uncondBranch(ThreadID tid, Addr pc, void * &bpHistory)
+{
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->takenUsed = true;
+    history->takenPred = true;
+    history->notTakenPred = true;
+    history->finalPred = true;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, true);
+}
+
+void
+YagsBP::squash(ThreadID tid, void *bpHistory)
+{
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+    globalHistoryReg[tid] = history->globalHistoryReg;
+
+    delete history;
+}
+
+/*
+ * Here we lookup the actual branch prediction. We use the PC to
+ * identify the bias of a particular branch, which is based on the
+ * prediction in the choice array. A hash of the global history
+ * register and a branch's PC is used to index into both the taken
+ * and not-taken predictors, which both present a prediction. The
+ * choice array's prediction is used to select between the two
+ * direction predictors for the final branch prediction.
+ */
+bool
+YagsBP::lookup(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    unsigned choiceHistoryIdx = ((branchAddr >> instShiftAmt)
+                                & choiceHistoryMask);
+    unsigned globalHistoryIdx = (((branchAddr >> instShiftAmt)
+                                ^ globalHistoryReg[tid])
+                                & globalHistoryMask);
+
+    assert(choiceHistoryIdx < choicePredictorSize);
+    assert(globalHistoryIdx < globalPredictorSize);
+
+    bool choicePrediction = choiceCounters[choiceHistoryIdx].read()
+                            > choiceThreshold;
+    bool takenGHBPrediction = takenCounters[globalHistoryIdx].read()
+                              > takenThreshold;
+    bool notTakenGHBPrediction = notTakenCounters[globalHistoryIdx].read()
+                                 > notTakenThreshold;
+    bool finalPrediction;
+
+    BPHistory *history = new BPHistory;
+    history->globalHistoryReg = globalHistoryReg[tid];
+    history->takenUsed = choicePrediction;
+    history->takenPred = takenGHBPrediction;
+    history->notTakenPred = notTakenGHBPrediction;
+
+    if (choicePrediction) {
+        finalPrediction = takenGHBPrediction;
+    } else {
+        finalPrediction = notTakenGHBPrediction;
+    }
+
+    history->finalPred = finalPrediction;
+    bpHistory = static_cast<void*>(history);
+    updateGlobalHistReg(tid, finalPrediction);
+
+    return finalPrediction;
+}
+
+void
+YagsBP::btbUpdate(ThreadID tid, Addr branchAddr, void * &bpHistory)
+{
+    globalHistoryReg[tid] &= (historyRegisterMask & ~ULL(1));
+}
+
+/* Only the selected direction predictor will be updated with the final
+ * outcome; the status of the unselected one will not be altered. The choice
+ * predictor is always updated with the branch outcome, except when the
+ * choice is opposite to the branch outcome but the selected counter of
+ * the direction predictors makes a correct final prediction.
+ */
+void
+YagsBP::update(ThreadID tid, Addr branchAddr, bool taken, void *bpHistory,
+                 bool squashed)
+{
+    assert(bpHistory);
+
+    BPHistory *history = static_cast<BPHistory*>(bpHistory);
+
+    // We do not update the counters speculatively on a squash.
+    // We just restore the global history register.
+    if (squashed) {
+        globalHistoryReg[tid] = (history->globalHistoryReg << 1) | taken;
+        return;
+    }
+
+    unsigned choiceHistoryIdx = ((branchAddr >> instShiftAmt)
+                                & choiceHistoryMask);
+    unsigned globalHistoryIdx = (((branchAddr >> instShiftAmt)
+                                ^ history->globalHistoryReg)
+                                & globalHistoryMask);
+
+    assert(choiceHistoryIdx < choicePredictorSize);
+    assert(globalHistoryIdx < globalPredictorSize);
+
+    if (history->takenUsed) {
+        // if the taken array's prediction was used, update it
+        if (taken) {
+            takenCounters[globalHistoryIdx].increment();
+        } else {
+            takenCounters[globalHistoryIdx].decrement();
+        }
+    } else {
+        // if the not-taken array's prediction was used, update it
+        if (taken) {
+            notTakenCounters[globalHistoryIdx].increment();
+        } else {
+            notTakenCounters[globalHistoryIdx].decrement();
+        }
+    }
+
+    if (history->finalPred == taken) {
+       /* If the final prediction matches the actual branch's
+        * outcome and the choice predictor matches the final
+        * outcome, we update the choice predictor, otherwise it
+        * is not updated. While the designers of the bi-mode
+        * predictor don't explicity say why this is done, one
+        * can infer that it is to preserve the choice predictor's
+        * bias with respect to the branch being predicted; afterall,
+        * the whole point of the bi-mode predictor is to identify the
+        * atypical case when a branch deviates from its bias.
+        */
+        if (history->finalPred == history->takenUsed) {
+            if (taken) {
+                choiceCounters[choiceHistoryIdx].increment();
+            } else {
+                choiceCounters[choiceHistoryIdx].decrement();
+            }
+        }
+    } else {
+        // always update the choice predictor on an incorrect prediction
+        if (taken) {
+            choiceCounters[choiceHistoryIdx].increment();
+        } else {
+            choiceCounters[choiceHistoryIdx].decrement();
+        }
+    }
+
+    delete history;
+}
+
+unsigned
+YagsBP::getGHR(ThreadID tid, void *bp_history) const
+{
+    return static_cast<BPHistory*>(bp_history)->globalHistoryReg;
+}
+
+void
+YagsBP::updateGlobalHistReg(ThreadID tid, bool taken)
+{
+    globalHistoryReg[tid] = taken ? (globalHistoryReg[tid] << 1) | 1 :
+                               (globalHistoryReg[tid] << 1);
+    globalHistoryReg[tid] &= historyRegisterMask;
+}
+
+YagsBP*
+YagsBPParams::create()
+{
+    return new YagsBP(this);
+}
diff -r 7f72aa0fe202 -r 6bb558b3407e src/cpu/pred/yags.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/pred/yags.hh	Wed Feb 13 02:14:25 2019 -0600
@@ -0,0 +1,86 @@
+/* @file
+ * Implementation of a yags branch predictor
+ */
+
+#ifndef __CPU_PRED_YAGS_PRED_HH__
+#define __CPU_PRED_YAGS_PRED_HH__
+
+#include "cpu/pred/bpred_unit.hh"
+#include "cpu/pred/sat_counter.hh"
+#include "params/YagsBP.hh"
+
+class YagsBP : public BPredUnit
+{
+  public:
+    YagsBP(const YagsBPParams *params);
+    void uncondBranch(ThreadID tid, Addr pc, void * &bp_history);
+    void squash(ThreadID tid, void *bp_history);
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed);
+    unsigned getGHR(ThreadID tid, void *bp_history) const;
+
+  private:
+    void updateGlobalHistReg(ThreadID tid, bool taken);
+
+    struct BPHistory {
+        unsigned globalHistoryReg;
+        // was the taken array's prediction used?
+        // true: takenPred used
+        // false: notPred used
+        bool takenUsed;
+        // prediction of the taken array
+        // true: predict taken
+        // false: predict not-taken
+        bool takenPred;
+        // prediction of the not-taken array
+        // true: predict taken
+        // false: predict not-taken
+        bool notTakenPred;
+        // the final taken/not-taken prediction
+        // true: predict taken
+        // false: predict not-taken
+        bool finalPred;
+    };
+
+    // choice predictors
+    std::vector<SatCounter> choiceCounters;
+
+    // taken direction predictors
+    std::vector<SatCounter> takenCountersA;
+    std::vector<unsigned> takenTagsA;
+    std::vector<SatCounter> takenCountersB;
+    std::vector<unsigned> takenTagsB;
+    std::vector<bool> takenLru;
+
+    // not-taken direction predictors
+    std::vector<SatCounter> notTakenCountersA;
+    std::vector<unsigned> notTakenTagsA;
+    std::vector<SatCounter> notTakenCountersB;
+    std::vector<unsigned> notTakenTagsB;
+    std::vector<bool> notTakenLru;
+
+    std::vector<unsigned> globalHistoryReg;
+    unsigned globalHistoryBits;
+    unsigned historyRegisterMask;
+    
+    // Choice Predictor Params
+    unsigned choicePredictorSize;
+    unsigned choiceCtrBits;
+    unsigned choiceHistoryMask;
+
+    // Global History Predictor Params
+    unsigned globalPredictorSize;
+    unsigned globalCtrBits;
+    unsigned globalHistoryMask;
+
+    // Tag mask for address compare
+    unsigned tagMask;
+
+    unsigned choiceThreshold;
+    unsigned takenThreshold;
+    unsigned notTakenThreshold;
+};
+
+#endif // __CPU_PRED_YAGS_PRED_HH__
